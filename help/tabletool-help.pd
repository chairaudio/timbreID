#N canvas 361 160 810 471 10;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-table-1 32 float 1;
#A 0 -0.900007 -0.207146 -0.0857167 -0.00476378 0.0761891 -0.4 -0.385714
0.371429 0.442858 0.514287 0.685717 0.757146 0.828575 0.428572 0.085713
0.628571 -0.457148 -0.58572 -0.68572 -0.200003 0.242857 0.400001 0.657145
0.357143 -0.0857167 -0.600006 -0.742864 -0.385719 0.0571414 0.271428
0.514287 0.642859;
#X coords 0 1 31 -1 200 140 1 0 0;
#X restore 55 57 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-table-2 32 float 1;
#A 0 0.757143 0.764286 0.771429 0.771429 0.771429 0.771429 0.771429
0.771429 0.771429 0.771429 0.75 0.728572 0.628571 0.0285673 -0.600008
-0.685723 -0.700009 -0.700009 -0.700009 -0.700009 -0.700009 -0.700009
-0.700009 -0.700009 -0.700009 -0.700009 -0.700009 -0.700009 -0.700009
-0.700009 -0.72858 -0.885724;
#X coords 0 1 31 -1 200 140 1 0 0;
#X restore 265 57 graph;
#N canvas 716 243 989 662 request-info 0;
#X msg 253 40 dump;
#X msg 479 456 restore;
#X msg 469 431 store;
#X msg 490 480 wipe;
#X msg 450 327 std;
#X msg 396 254 mean;
#X msg 420 290 geomean;
#X msg 354 183 sum;
#X text 297 39 Dump all values to a list at the right outlet.;
#X text 365 146 Ask for the length of the table.;
#X text 62 21 Specify the active table.;
#X text 540 455 Restore the stored values after you've messsed them
up.;
#X text 533 480 Wipe all memory.;
#X text 466 356 Store the table values to internal memory. Note that
if you store a table \, then set to a different active table \, the
internal memory will still contain the former table's values. Hit store
again to update memory after setting to the new table.;
#X text 388 182 Sum all values.;
#X text 435 253 Take the arithmetic mean.;
#X text 486 327 Calculate standard deviation.;
#X msg 323 147 size;
#X text 484 289 Take the geometric mean. You will get NANs on negative
data.;
#X text 407 74 Dump values in a certain range to a list at the right
outlet.;
#X msg 274 80 dump_range 17 29;
#X msg 373 218 range;
#X text 427 218 Find the range of the table data;
#X msg 514 532 choose;
#X text 571 526 Randomly select a value from the table. The index of
the chosen value is reported at the right outlet.;
#X msg 33 65 set \$1-table-1;
#X obj 33 25 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 33 45 f \$0;
#X obj 73 96 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 73 116 f \$0;
#X msg 73 136 set \$1-table-2;
#X obj 253 601 s \$0-tool-1;
#X text 347 104 Iterate through the table and send each value out the
left outlet as quickly as possible.;
#X msg 294 110 drip;
#X msg 604 173 mode;
#X msg 634 222 median;
#X connect 0 0 31 0;
#X connect 1 0 31 0;
#X connect 2 0 31 0;
#X connect 3 0 31 0;
#X connect 4 0 31 0;
#X connect 5 0 31 0;
#X connect 6 0 31 0;
#X connect 7 0 31 0;
#X connect 17 0 31 0;
#X connect 20 0 31 0;
#X connect 21 0 31 0;
#X connect 23 0 31 0;
#X connect 25 0 31 0;
#X connect 26 0 27 0;
#X connect 27 0 25 0;
#X connect 28 0 29 0;
#X connect 29 0 30 0;
#X connect 30 0 31 0;
#X connect 33 0 31 0;
#X connect 34 0 31 0;
#X connect 35 0 31 0;
#X restore 55 383 pd request-info;
#N canvas 255 327 868 653 multi-table-math 0;
#X text 22 65 Dot product;
#X text 22 85 Euclidean distance;
#X text 22 105 Taxicab distance;
#X text 22 125 Pearson correlation;
#X text 66 354 Add value pairs by index., f 16;
#X text 90 426 Subtract value pairs by index., f 15;
#X text 378 405 Multiply value pairs by index.;
#X text 396 475 Divide value pairs by index.;
#X text 23 17 These four functions operate between the active table
and the table passed with the message.;
#X text 58 278 These functions perform arithmetic on the active table
and a table passed with the message. Results are sent out the right
outlet as a list.;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-multi-math 32 float 0;
#X coords 0 1 31 -1 200 140 1 0 0;
#X restore 605 399 graph;
#X obj 366 552 list prepend 0;
#X obj 366 573 s \$0-multi-math;
#X obj 231 517 tabletool \$0-table-1;
#X msg 535 88 taxi \$1-table-2;
#X msg 595 158 corr \$1-table-2;
#X obj 535 48 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 535 68 f \$0;
#X obj 595 118 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 595 138 f \$0;
#X obj 265 48 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 265 68 f \$0;
#X obj 325 118 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 325 138 f \$0;
#X msg 265 88 dot \$1-table-2;
#X msg 325 158 euclid \$1-table-2;
#X obj 265 199 tabletool \$0-table-1;
#X obj 535 199 tabletool \$0-table-1;
#X floatatom 535 221 5 0 0 0 - - -, f 5;
#X floatatom 265 221 5 0 0 0 - - -, f 5;
#X obj 20 356 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 20 376 f \$0;
#X msg 231 406 multiply \$1-table-2;
#X msg 260 476 divide \$1-table-2;
#X obj 153 564 list prepend 0;
#X obj 153 585 s \$0-multi-math;
#X obj 21 527 tabletool \$0-table-1;
#X msg 20 396 add \$1-table-2;
#X msg 40 466 subtract \$1-table-2;
#X obj 40 426 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 40 446 f \$0;
#X obj 231 366 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 231 386 f \$0;
#X obj 260 436 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 260 456 f \$0;
#X connect 11 0 12 0;
#X connect 13 1 11 0;
#X connect 14 0 27 0;
#X connect 15 0 27 0;
#X connect 16 0 17 0;
#X connect 17 0 14 0;
#X connect 18 0 19 0;
#X connect 19 0 15 0;
#X connect 20 0 21 0;
#X connect 21 0 24 0;
#X connect 22 0 23 0;
#X connect 23 0 25 0;
#X connect 24 0 26 0;
#X connect 25 0 26 0;
#X connect 26 0 29 0;
#X connect 27 0 28 0;
#X connect 30 0 31 0;
#X connect 31 0 37 0;
#X connect 32 0 13 0;
#X connect 33 0 13 0;
#X connect 34 0 35 0;
#X connect 36 1 34 0;
#X connect 37 0 36 0;
#X connect 38 0 36 0;
#X connect 39 0 40 0;
#X connect 40 0 38 0;
#X connect 41 0 42 0;
#X connect 42 0 32 0;
#X connect 43 0 44 0;
#X connect 44 0 33 0;
#X restore 332 343 pd multi-table-math;
#N canvas 140 390 1164 528 manipulations-1 0;
#X msg 18 37 offset 1;
#X msg 112 177 shift -5;
#X msg 98 157 shift 5;
#X msg 31 57 offset -0.1;
#X text 88 36 Add a positive or negative offset to all values.;
#X text 187 161 Shift elements by index forward or back. The overflow
wraps around to the beginning or end appropriately.;
#X msg 58 97 scale 0.5;
#X msg 71 117 scale 2;
#X text 136 97 Multiply all values by a scalar;
#X text 136 339 Copy another table to the currently set table.;
#X text 159 440 Copy part of another table to the currently set table.
First argument is the starting index for writing to the target table.
The remaining arguments are the table to copy from \, and the start
and end indices of the desired range.;
#X msg 672 344 normalize_sum;
#X msg 632 284 normalize -1 1;
#X text 778 337 Normalize so that all values are between 0 and 1 \,
and the sum == 1;
#X text 744 283 Normalize to a range with a specified minimum and maximum.
;
#X msg 632 59 const 0.77 7 17;
#X text 631 39 Write a constant to a range of the table.;
#X msg 682 170 insert 7 0.77;
#X msg 122 211 shift0 5;
#X text 195 211 Like shift \, but fill excess with zeros.;
#X msg 662 119 remove 7;
#X text 732 103 Remove the value at a certain index \, and send it
out the left outlet. This shifts remaining elements left and writes
a zero to the end.;
#X text 791 166 Starting at a certain index \, insert a value. Remaining
values are shifted right \, and the last value is shifted off of the
table and sent out the left outlet.;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-table-3 64 float 1;
#A 0 -0.485715 -0.457144 -0.400001 -0.400001 -0.400001 -0.428572 -0.542859
-0.57143 -0.57143 -0.600002 -0.600002 -0.600002 -0.342857 -0.285714
-0.114284 -0.0285697 0.0857168 0.0857168 0.0857168 0.0571452 0.0285736
-0.0571413 -0.114284 -0.199999 -0.228571 -0.228571 -0.257142 -0.285714
-0.285714 -0.285714 -0.285714 -0.285714 -0.257142 1.95205e-06 0.228575
0.31429 0.428576 0.457148 0.457148 0.457148 0.457148 0.342861 0.285718
0.228575 0.200003 0.200003 0.200003 0.200003 0.200003 0.200003 0.200003
0.200003 0.200003 0.257146 0.285718 0.371433 0.514291 0.600006 0.628577
0.628577 0.628577 0.628577 0.628577 0.514291;
#X coords 0 1 63 -1 100 70 1 0 0;
#X restore 400 72 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-copy 32 float 0;
#X coords 0 1 31 -1 100 70 1 0 0;
#X restore 490 342 graph;
#X obj 18 262 tabletool \$0-table-3;
#X obj 18 458 tabletool \$0-copy;
#X msg 18 340 copy \$1-table-2;
#X obj 18 300 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 18 320 f \$0;
#X obj 49 370 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 49 390 f \$0;
#X msg 49 410 copy_range 25 \$1-table-1 0 3;
#X obj 632 202 tabletool \$0-copy;
#X obj 632 385 tabletool \$0-copy;
#X connect 0 0 25 0;
#X connect 1 0 25 0;
#X connect 2 0 25 0;
#X connect 3 0 25 0;
#X connect 6 0 25 0;
#X connect 7 0 25 0;
#X connect 11 0 34 0;
#X connect 12 0 34 0;
#X connect 15 0 33 0;
#X connect 17 0 33 0;
#X connect 18 0 25 0;
#X connect 20 0 33 0;
#X connect 27 0 26 0;
#X connect 28 0 29 0;
#X connect 29 0 27 0;
#X connect 30 0 31 0;
#X connect 31 0 32 0;
#X connect 32 0 26 0;
#X restore 55 323 pd manipulations-1;
#N canvas 108 81 1119 640 manipulations-2 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-tables-1-2 64 float 0;
#X coords 0 1 63 -1 100 70 1 0 0;
#X restore 394 171 graph;
#X obj 182 183 list prepend 0;
#X text 264 124 Or concatenate the active table with another table.
;
#X text 167 48 Lace the active table with another table \, sending
the results out the right outlet as a list.;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-manip 64 float 1;
#A 0 -0.414301 0.414289 0.457147 -0.12858 -0.0952462 -0.495255 -0.614306
-5.90086e-06 0.114282 -5.90086e-06 -0.142866 0.457147 -0.185724 0.0285662
-0.514303 0.371431 -0.371443 -5.90086e-06 -0.0571501 -0.533351 0.514292
-0.578591 -0.552399 -0.628592 -0.171438 0.457147 -0.314299 0.142855
0.685724 0.128568 0.257143 0.314287 -0.0761981 -5.90086e-06 0.400003
-0.60002 -0.585734 -0.592877 -5.90086e-06 -0.385729 -0.342871 -0.428587
-0.485731 0.48572 -0.457159 0.285715 -0.300013 -0.504779 0.385717 -0.114294
-0.257155 -0.20001 0.228571 0.357145 -0.214297 0.185713 0.342859 -0.228583
-0.400015 -0.0571501 0.0714243 -0.285727 -0.571447 0.48572;
#X coords 0 1 63 -1 100 70 1 0 0;
#X restore 475 339 graph;
#X msg 126 371 reverse;
#X msg 76 291 sort;
#X msg 54 263 scramble;
#X text 124 262 Shuffle table elements in a random order.;
#X text 192 370 Reverse the order of all elements.;
#X text 121 286 Sort values from low to high and reorder. For high
to low ordering \, use "sort" \, then "reverse".;
#X msg 96 331 sort_range 7 15;
#X text 215 330 Sort only a specific range.;
#X msg 179 450 swap 0 31;
#X text 257 449 Swap a pair of values at certain indices.;
#X msg 662 330 differentiate;
#X text 661 46 If table size == N \, this creates a list of N values
where term_i = tablevalue_i + tablevalue_i-1 ... tablevalue_0. This
is useful when you have a table full of inter onset values and want
the total duration at any given point.;
#X text 661 298 This creates a list of N values where term_i = tablevalue_i
- tablevalue_i-1.;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-int-diff 32 float 0;
#X coords 0 1 31 -1 100 70 1 0 0;
#X restore 662 198 graph;
#X obj 811 380 list prepend 0;
#X obj 811 166 list prepend 0;
#X msg 662 116 integrate;
#X text 248 405 Replace all occurrences of the first value with the
second, f 31;
#X msg 149 410 replace 0 1;
#X obj 182 204 s \$0-tables-1-2;
#X obj 54 156 tabletool \$0-table-1;
#X msg 54 55 lace \$1-table-2;
#X msg 94 125 concatenate \$1-table-2;
#X obj 54 15 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 54 35 f \$0;
#X obj 54 593 tabletool \$0-manip;
#X msg 249 556 smooth;
#X msg 209 490 invert;
#X text 266 489 Flip all values. Low becomes high and vice versa.;
#X msg 229 525 abs;
#X text 263 525 Absolute value;
#X text 305 552 Smooth out data by averaging with neighboring values.
;
#X obj 94 85 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 94 105 f \$0;
#X obj 662 137 tabletool \$0-table-1;
#X obj 811 187 s \$0-int-diff;
#X obj 811 401 s \$0-int-diff;
#X obj 662 351 tabletool \$0-table-1;
#X obj 791 562 print as_set;
#X msg 662 480 as_set;
#X floatatom 662 572 5 0 0 0 - - -, f 5;
#X obj 662 531 tabletool \$0-table-2;
#X text 740 463 Return a copy of the table data as a set with no duplicate
values. The set appears as a list at the right outlet \, and the number
of unique elements in the set appears at the left., f 48;
#X connect 1 0 24 0;
#X connect 5 0 30 0;
#X connect 6 0 30 0;
#X connect 7 0 30 0;
#X connect 11 0 30 0;
#X connect 13 0 30 0;
#X connect 15 0 42 0;
#X connect 19 0 41 0;
#X connect 20 0 40 0;
#X connect 21 0 39 0;
#X connect 23 0 30 0;
#X connect 25 1 1 0;
#X connect 26 0 25 0;
#X connect 27 0 25 0;
#X connect 28 0 29 0;
#X connect 29 0 26 0;
#X connect 31 0 30 0;
#X connect 32 0 30 0;
#X connect 34 0 30 0;
#X connect 37 0 38 0;
#X connect 38 0 27 0;
#X connect 39 1 20 0;
#X connect 42 1 19 0;
#X connect 44 0 46 0;
#X connect 46 0 45 0;
#X connect 46 1 43 0;
#X restore 55 343 pd manipulations-2;
#N canvas 162 81 913 727 filling 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-fill 1024 float 0;
#X coords 0 1 1023 0 200 140 1 0 0;
#X restore 609 90 graph;
#X msg 57 51 blackman;
#X msg 67 71 cosine;
#X msg 77 91 hamming;
#X msg 87 111 hann;
#X text 155 60 Write common windowing functions to an array. Windows
are calculated based on the current array size \, so resize beforehand
if you want a certain resolution.;
#X msg 57 222 randFill -0.75 0.7;
#X text 208 223 Fill an array with random numbers in a certain range.
;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-series 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 609 340 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-walk 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 609 540 graph;
#X msg 57 372 series -1 1 1;
#X msg 97 433 series -0.75 1 \$1;
#X floatatom 97 410 5 0 0 0 - - -, f 5;
#X text 138 409 Shift drag to try different exponents.;
#X msg 57 582 random_walk -0.4 0.1 -1 1;
#X text 55 546 Generate a random walk. Arguments: starting value \,
step value \, lower limit \, upper limit.;
#X text 55 323 Generate a series of values between two points. Final
argument is the exponent of the curve. An exponent of 1 will give a
straight line.;
#X obj 57 152 tabletool \$0-fill;
#X obj 57 474 tabletool \$0-series;
#X obj 57 614 tabletool \$0-walk;
#X obj 57 262 tabletool \$0-series;
#X connect 1 0 17 0;
#X connect 2 0 17 0;
#X connect 3 0 17 0;
#X connect 4 0 17 0;
#X connect 6 0 20 0;
#X connect 10 0 18 0;
#X connect 11 0 18 0;
#X connect 12 0 11 0;
#X connect 14 0 19 0;
#X restore 332 323 pd filling;
#X obj 4 4 cnv 10 400 10 empty empty empty 20 12 0 14 -233017 -66577
0;
#X obj 4 4 cnv 10 10 400 empty empty empty 20 12 0 14 -233017 -66577
0;
#N canvas 308 126 803 390 manipulations-3 0;
#X msg 119 127 ceil;
#X msg 150 169 floor;
#X msg 35 43 clip -2 3;
#X msg 270 289 reciprocal;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-table-4 64 float 1;
#A 0 -0.714283 1.57142 4.2857 5.42855 6.14283 6.42855 6.5714 6.5714
6.5714 6.71426 6.71426 6.71426 6.64283 6.5714 5.42855 4.14284 2.99999
-1.28571 -3.14285 -6.14283 -6.28569 -8.5714 -8.5714 -7.14283 -5.85712
-4.57141 -3.71427 -3.14285 -2.99999 -2.99999 -3.14285 -3.85713 -4.99998
-5.28569 -5.57141 -5.57141 -4.57141 -3.2857 -1.71428 0.571426 1.42857
2.57142 3.42856 3.85713 4.71427 5.42855 5.85712 5.99998 6.28569 6.28569
6.71426 6.71426 6.71426 6.71426 6.71426 6.28569 5.57141 4.71427 4.71427
4.99998 5.71426 6.99997 8.14283 8.42854;
#X coords 0 10 63 -10 200 140 1 0 0;
#X restore 542 30 graph;
#X text 112 42 Clip all values in table to lower and upper limits;
#X text 150 85 Round all values in table to a given resolution;
#X text 169 126 Set all values to the next highest integer;
#X text 209 168 Set all values to the next lowest integer;
#X obj 35 325 tabletool \$0-table-4;
#X msg 69 86 round 0.5;
#X text 354 289 Take the reciprocal of all values;
#X msg 190 209 bash_above 3 0;
#X msg 230 249 bash_below -3 -10;
#X text 363 244 bash any values below a threshold (\$1) to the given
value (\$2), f 39;
#X text 305 203 bash any values above a threshold (\$1) to the given
value (\$2), f 39;
#X connect 0 0 9 0;
#X connect 1 0 9 0;
#X connect 2 0 9 0;
#X connect 3 0 9 0;
#X connect 10 0 9 0;
#X connect 12 0 9 0;
#X connect 13 0 9 0;
#X restore 55 363 pd manipulations-3;
#N canvas 308 126 1046 503 conversion 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-conversion 64 float 0;
#X coords 0 107.22 63 21.0007 200 140 1 0 0;
#X restore 738 57 graph;
#X msg 43 39 mtof;
#X text 120 38 Convert all values from MIDI to frequency in Hz;
#X msg 77 82 ftom;
#X msg 127 123 dbtorms;
#X msg 158 165 rmstodb;
#X obj 43 431 tabletool \$0-conversion;
#X msg 178 205 bin2freq 2048 44100;
#X msg 198 255 freq2bin 2048 44100;
#X text 327 199 Convert from bin number to frequency based on a given
window size and sampling rate, f 43;
#X msg 228 305 bark2freq;
#X msg 258 335 freq2bark;
#X text 307 304 Convert from Bark to frequency in Hz;
#X text 337 334 Convert from frequency in Hz to Bark;
#X text 143 81 Convert all values from frequency in Hz to MIDI;
#X text 198 122 Convert all values from decibels to RMS amplitude;
#X text 237 164 Convert all values from RMS amplitude decibels;
#X text 347 250 Convert from frequency to bin number based on a given
window size and sampling rate, f 44;
#X obj 680 435 tabletool \$0-conversion;
#X msg 680 343 fit_bounds;
#X msg 720 403 randFill 21 108;
#X text 774 304 Between commands \, you'll need to re-fit the boundaries
of the table since the unit ranges here vary wildly..., f 24;
#X obj 680 291 loadbang;
#X obj 680 313 t b b;
#X text 842 402 << MIDI range of a piano;
#X connect 1 0 6 0;
#X connect 3 0 6 0;
#X connect 4 0 6 0;
#X connect 5 0 6 0;
#X connect 7 0 6 0;
#X connect 8 0 6 0;
#X connect 10 0 6 0;
#X connect 11 0 6 0;
#X connect 19 0 18 0;
#X connect 20 0 18 0;
#X connect 22 0 23 0;
#X connect 23 0 19 0;
#X connect 23 1 20 0;
#X restore 202 363 pd conversion;
#N canvas 836 346 463 407 properties 0;
#X msg 65 183 fit_bounds;
#N canvas 0 50 450 278 (subpatch) 0;
#X array \$0-fitBoundsTest 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 231 123 graph;
#X text 29 15 The fit_bounds method finds the maximum and minimum values
in a table and changes the table display properties so that the Y range
fits the data perfectly. Try it below by generating some random numbers
to fill this table \, and then hit the fit_bounds message;
#X obj 92 331 f \$0;
#X obj 92 301 loadbang;
#X obj 25 235 tabletool \$0-fitBoundsTest;
#X msg 92 353 \; \$1-fitBoundsTest bounds 0 1 63 -1 \;;
#X msg 25 146 randFill -2 2;
#X obj 72 331 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X connect 0 0 5 0;
#X connect 3 0 6 0;
#X connect 4 0 3 0;
#X connect 7 0 5 0;
#X connect 8 0 3 0;
#X restore 332 383 pd properties;
#N canvas 281 295 1223 500 searching-2 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array valleys 64 float 1;
#A 0 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.714286 -0.05
-0.05 -0.05 -0.05 -0.185714 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05
-0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.928571 -0.05 -0.05 -0.05
-0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05
-0.05 -0.05 -0.05 -0.05 -0.857143 -0.05 -0.05 -0.05 -0.05 -0.471429
-0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05 -0.05;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 361 46 graph;
#X obj 322 396 tabletool peaks;
#X obj 322 418 pack f f;
#X obj 322 439 print;
#X obj 24 350 tabletool peaks;
#X msg 322 355 peaks_thresh 0.05 0.05;
#N canvas 0 50 450 300 (subpatch) 0;
#X array peaks 64 float 1;
#A 0 0 0 0 0 0.957143 0 0 0 0 0 0 0 0 0 0.607143 0 0 0 0 0 0.0428572
0 0 0 0 0 0 0 0.0857143 0 0 0 0 0.635714 0 0 0 0 0 0 0.3 0 0 0 0 0
0 0.842857 0 0 0 0 0 0 0 0 0 0 0 0 0.507143 0 0 0;
#X coords 0 1 63 0 200 140 1 0 0;
#X restore 51 46 graph;
#X obj 794 227 tabletool valleys;
#X obj 829 177 t b a b;
#X msg 829 146 valleys \$1;
#X floatatom 829 115 5 0 100 0 - - -, f 5;
#X obj 49 296 t b a b;
#X msg 49 265 peaks \$1;
#X floatatom 49 244 5 0 100 0 - - -, f 5;
#N canvas 1228 305 450 300 send-label 0;
#X obj 77 27 inlet;
#X obj 197 27 inlet;
#X obj 327 27 inlet;
#X obj 197 96 list prepend;
#X obj 295 101 t l;
#X obj 156 121 list;
#X obj 156 165 list prepend xlabel;
#X obj 156 187 list trim;
#X obj 156 209 s valleys;
#X obj 156 143 list prepend -1;
#X connect 0 0 5 0;
#X connect 1 0 3 0;
#X connect 2 0 3 1;
#X connect 3 0 4 0;
#X connect 3 0 5 1;
#X connect 4 0 3 1;
#X connect 5 0 9 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 9 0 6 0;
#X restore 883 267 pd send-label;
#N canvas 1228 305 450 300 send-label 0;
#X obj 77 27 inlet;
#X obj 197 27 inlet;
#X obj 327 27 inlet;
#X obj 197 96 list prepend;
#X obj 295 101 t l;
#X obj 156 121 list;
#X obj 156 165 list prepend xlabel;
#X obj 156 187 list trim;
#X obj 156 209 s peaks;
#X obj 156 143 list prepend 0;
#X connect 0 0 5 0;
#X connect 1 0 3 0;
#X connect 2 0 3 1;
#X connect 3 0 4 0;
#X connect 3 0 5 1;
#X connect 4 0 3 1;
#X connect 5 0 9 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 9 0 6 0;
#X restore 101 395 pd send-label;
#X text 442 394 Finally \, you can also search for peaks based on min
and max thresholds. A peak is reported when values cross the max threshold
\, then fall below the min threshold. For each peak \, the peak value
within those boundaries appears at the left outlet \, and its index
at the right.;
#X text 884 75 You can search for valleys in a similar fashion based
on a percent threshold. All valleys below the threshold percent of
the minimum valley will be reported., f 42;
#X text 140 218 Search for peaks based on changes in slope from positive
to negative. A threshold in percent allows you to show only the maximum
peak \, all peaks \, or anything in-between. With the threshold at
100 \, only the maximum peak data will be output. At 50% \, all peaks
that are at least 50% of the height of the maximum peak will be reported.
Left outlet gives the peak value \, and right outlet gives the peak
index in the table. Here \, the indices are accumulated into a list
in order to label peak indices directly on the table., f 89;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 2 0 3 0;
#X connect 4 1 15 1;
#X connect 5 0 1 0;
#X connect 7 1 14 1;
#X connect 8 0 14 0;
#X connect 8 1 7 0;
#X connect 8 2 14 2;
#X connect 9 0 8 0;
#X connect 10 0 9 0;
#X connect 11 0 15 0;
#X connect 11 1 4 0;
#X connect 11 2 15 2;
#X connect 12 0 11 0;
#X connect 13 0 12 0;
#X restore 202 343 pd searching-2;
#X obj 641 237 print t1-right;
#X obj 515 281 print t1-left;
#X obj 515 161 r \$0-tool-1;
#X obj 515 209 tabletool \$0-table-1;
#N canvas 347 194 1155 661 searching-1 0;
#X msg 76 45 equals 0;
#X msg 117 452 max;
#X msg 87 421 min;
#X text 125 420 Minimum value in table.;
#X msg 157 531 nearest 0.5;
#X text 254 525 Nearest value in table. The value itself appears at
the left outlet \, and its index at the right.;
#X msg 127 125 greater 0.3;
#X msg 166 215 less -0.1;
#X text 155 451 Maximum value in table.;
#X msg 176 285 between -0.5 0.5;
#X msg 137 488 max_mag;
#X text 204 481 Value in table with the maximum magnitude (regardless
of sign);
#X msg 676 70 change;
#X text 777 51 Search for any changes in the table. If any value has
changed since the last time this method was called \, it is sent out
the left outlet \, and its index out the right outlet. Bang repeatedly
with a metro to update constantly., f 41;
#X msg 649 345 find_zero_crossings;
#X obj 76 355 s \$0-tool-1;
#X obj 87 582 s \$0-tool-1;
#X obj 649 437 s \$0-tool-1;
#X text 670 375 Search for zero crossings. Left outlet reports the
number of zero crossings \, and right outlet supplies a list of the
crossing indices.;
#X obj 676 111 s \$0-tool-1;
#X text 173 23 Search for occurrences of a particular value \, and
get their indices. If the requested value is not present in the table
\, -1 shows up at the left outlet. Otherwise \, the number of occurrences
shows up at the left outlet \, and a list of their indices is spat
out the right.;
#X text 223 103 Search for values that are greater than a particular
value \, and get their indices. If no values in the table are greater
\, -1 shows up at the left outlet. Otherwise \, the number of greater
values shows up at the left outlet \, and a list of their indices is
spat out the right.;
#X text 264 193 Search for values that are less than a particular value
\, and get their indices. If no values in the table are lesser \, -1
shows up at the left outlet. Otherwise \, the number of lesser values
shows up at the left outlet \, and a list of their indices is spat
out the right.;
#X text 305 284 Look for values between two bounds (non-inclusive)
;
#X connect 0 0 15 0;
#X connect 1 0 16 0;
#X connect 2 0 16 0;
#X connect 4 0 16 0;
#X connect 6 0 15 0;
#X connect 7 0 15 0;
#X connect 9 0 15 0;
#X connect 10 0 16 0;
#X connect 12 0 19 0;
#X connect 14 0 17 0;
#X restore 202 323 pd searching-1;
#X text 53 219 [tabletool] manipulates \, searches \, and provides
information about tables and their data. Generally \, when the output
of a command is a single number \, it shows up at the left outlet.
When the output is a list \, it is sent out the right outlet. Some
methods produce output at both outlets as value/index pairs \, and
others operate directly on the table data in place.;
#N canvas 572 286 770 509 overlap-add 0;
#N canvas 0 50 450 278 (subpatch) 0;
#X array \$0-ola-result 88200 float 0;
#X coords 0 1 88199 -1 200 140 1 0 0;
#X restore 406 309 graph;
#X obj 25 265 tabletool \$0-ola-result;
#X obj 459 227 table \$0-sample;
#X text 22 21 For non-real-time assembling of audio \, the overlap_add
method takes a range of samples from a table \, applies a specified
window \, and adds the windowed audio to the target table at the given
starting sample.;
#X obj 90 421 tabplay~ \$0-ola-result;
#X obj 90 452 dac~;
#X obj 25 115 f \$0;
#X obj 25 95 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 65 185 f \$0;
#X obj 65 165 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#N canvas 276 34 561 469 example-process 0;
#X obj 25 405 tabletool \$0-ola-result;
#X obj 25 355 pack f f \$0;
#X obj 25 89 t f b;
#X obj 5 140 until;
#X obj 25 201 f;
#X msg 45 178 0;
#X obj 25 262 t f b;
#X obj 85 312 random;
#X obj 55 202 + 2048;
#X msg 25 68 40;
#X obj 118 268 r \$0-overlap-add-source-len;
#X obj 118 289 - 8192;
#X obj 25 29 inlet;
#X text 137 54 Here's a toy example where we grab random 8192-point
grains from the source audio array (a recording of Satie) \, and overlap
them spaced 2048 samples apart using a Hann window. We do it 40 times
to fill up the \$0-ola-result array.;
#X msg 25 376 overlap_add \$2 8192 hann \$3-sample \$1;
#X connect 1 0 14 0;
#X connect 2 0 3 0;
#X connect 2 1 5 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 0 8 0;
#X connect 5 0 4 1;
#X connect 6 0 1 0;
#X connect 6 1 7 0;
#X connect 7 0 1 1;
#X connect 8 0 4 1;
#X connect 9 0 2 0;
#X connect 10 0 11 0;
#X connect 11 0 7 1;
#X connect 12 0 9 0;
#X connect 14 0 0 0;
#X restore 130 370 pd example-process;
#X obj 90 310 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#N canvas 719 470 450 300 load-sample 0;
#X obj 85 121 soundfiler;
#X obj 85 56 loadbang;
#X obj 85 77 f \$0;
#X msg 85 100 read -resize ./audio/satie.wav \$1-sample;
#X obj 125 162 s \$0-overlap-add-source-len;
#X obj 85 142 t b f;
#X obj 85 182 f \$0;
#X msg 85 203 \; \$1-sample normalize \;;
#X connect 0 0 5 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 0 0;
#X connect 5 0 6 0;
#X connect 5 1 4 0;
#X connect 6 0 7 0;
#X restore 459 247 pd load-sample;
#X obj 203 302 f \$0;
#X msg 203 323 \; \$1-ola-result const 0 \;;
#X obj 203 282 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 90 330 t b b b;
#X text 314 98 Arguments \; \$1: starting sample in source array \;
\$2: number of samples (range) \; \$3: window function name \; \$4:
source array symbol \; \$5: starting sample in target array \;;
#X text 574 128 Window function names \; rectangular \; blackman \;
cosine \; hamming \; hann \;;
#X msg 65 207 overlap_add 44100 32768 hann \$1-sample 17384;
#X msg 25 136 overlap_add 1000 32768 hann \$1-sample 1000;
#X connect 4 0 5 0;
#X connect 4 0 5 1;
#X connect 6 0 20 0;
#X connect 7 0 6 0;
#X connect 8 0 19 0;
#X connect 9 0 8 0;
#X connect 11 0 16 0;
#X connect 13 0 14 0;
#X connect 15 0 13 0;
#X connect 16 0 4 0;
#X connect 16 1 10 0;
#X connect 16 2 13 0;
#X connect 19 0 1 0;
#X connect 20 0 1 0;
#X restore 332 363 pd overlap-add;
#N canvas 727 422 652 250 permutations 0;
#X obj 66 114 tabletool \$0-perms;
#X obj 289 184 tabletool \$0-perms;
#X obj 289 137 loadbang;
#X msg 66 23 permute 2;
#X msg 86 53 permute 3;
#X obj 447 158 table \$0-perms 5;
#X floatatom 66 165 5 0 0 0 - - -, f 5;
#X obj 176 165 print;
#X msg 289 163 series 0 4 1;
#X text 227 29 The permute method lists all permutations (with repetition)
of the data in the target table. The number of elements in the permutation
results can be controlled with an argument. Here \, a table is filled
with 0 \, 1 \, 2 \, 3 \, 4 (via tabletool's series method) \, and we
get all 2-element or 3-element permutations of that set as a sequence
of lists out the right outlet. The left outlet reports the number of
resulting permutations.;
#X connect 0 0 6 0;
#X connect 0 1 7 0;
#X connect 2 0 8 0;
#X connect 3 0 0 0;
#X connect 4 0 0 0;
#X connect 8 0 1 0;
#X restore 202 383 pd permutations;
#X text 550 429 March 2018;
#X text 550 409 Updated for timbreID version 0.7.4;
#X connect 15 0 16 0;
#X connect 16 0 14 0;
#X connect 16 1 13 0;
